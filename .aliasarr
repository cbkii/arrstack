# shellcheck shell=bash
# arr-stack/.aliasarr — helpers & aliases for ARR+Gluetun+ProtonVPN stack
# Source from your shell:  [ -f "$ARR_STACK_DIR/.aliasarr" ] && source "$ARR_STACK_DIR/.aliasarr"
# Assumes the merged installer’s defaults; override via env before sourcing:
#   export ARR_BASE="$HOME/srv"
#   export ARR_STACK_DIR="$ARR_BASE/arr-stack"
#   export ARR_DOCKER_DIR="$ARR_BASE/docker"
#   export ARR_BACKUP_DIR="$ARR_BASE/backups"
#   export ARR_ENV_FILE="$ARR_STACK_DIR/.env"

# ----------------[ Core paths ]----------------
ARR_BASE="${ARR_BASE:-$HOME/srv}"
ARR_STACK_DIR="${ARR_STACK_DIR:-$ARR_BASE/arr-stack}"
ARR_DOCKER_DIR="${ARR_DOCKER_DIR:-$ARR_BASE/docker}"
ARR_BACKUP_DIR="${ARR_BACKUP_DIR:-$ARR_BASE/backups}"
ARR_ENV_FILE="${ARR_ENV_FILE:-$ARR_STACK_DIR/.env}"
ARR_DC=(docker compose --env-file "$ARR_ENV_FILE" -f "$ARR_STACK_DIR/docker-compose.yml")
ARRCONF_DIR="${ARRCONF_DIR:-$ARR_STACK_DIR/arrconf}"
PROTON_AUTH_FILE="${PROTON_AUTH_FILE:-$ARRCONF_DIR/proton.auth}"

# LAN IP for service bindings
LAN_IP="${LAN_IP:-192.168.1.50}"
LOCALHOST_ADDR="${LOCALHOST_ADDR:-$(_arr_get LOCALHOST_ADDR)}"
[[ -n "$LOCALHOST_ADDR" ]] || LOCALHOST_ADDR=127.0.0.1
GLUETUN_CONTROL_BIND_HOST="$(_arr_get GLUETUN_CONTROL_BIND_HOST)"
if [[ -z "$GLUETUN_CONTROL_BIND_HOST" ]]; then
  GLUETUN_CONTROL_BIND_HOST="$LOCALHOST_ADDR"
fi

# ----------------[ Utilities ]-----------------
_arr_exists() { docker ps -a --format '{{.Names}}' | grep -qx "$1"; }
_arr_dc()     { ( cd "$ARR_STACK_DIR" && "${ARR_DC[@]}" "$@" ); }
_arr_get()    { grep -E "^$1=" "$ARR_ENV_FILE" 2>/dev/null | sed 's/^[^=]*=//' | tr -d '"' ; }
_arr_access_host() {
  local host="${1:-${LAN_IP}}"
  if [[ -z "$host" || "$host" = "0.0.0.0" ]]; then
    host="$LOCALHOST_ADDR"
  fi
  printf '%s' "$host"
}
_arr_url()    { local host; host="$(_arr_access_host "$1")"; printf "http://%s:%s" "$host" "${2:?port}"; }
_arr_now()    { date +%Y%m%d-%H%M%S; }
_arr_info()   { printf "[arr] %s\n" "$*"; }
_arr_warn()   { printf "[arr:warn] %s\n" "$*" >&2; }

# Values pulled once from $ARR_ENV_FILE
GLUETUN_CONTROL_PORT="$(_arr_get GLUETUN_CONTROL_PORT)"; [[ -n "$GLUETUN_CONTROL_PORT" ]] || GLUETUN_CONTROL_PORT=8000
QBT_HTTP_PORT_HOST="$(_arr_get QBT_HTTP_PORT_HOST)"; [[ -n "$QBT_HTTP_PORT_HOST" ]] || QBT_HTTP_PORT_HOST=8080
GLUETUN_API_KEY="$(_arr_get GLUETUN_API_KEY)"
QBT_USER="$(_arr_get QBT_USER)"
QBT_PASS="$(_arr_get QBT_PASS)"
VPN_TYPE="$(_arr_get VPN_TYPE)"
[[ -n "$VPN_TYPE" ]] || VPN_TYPE="$(_arr_get VPN_MODE)"
VPN_MODE="$VPN_TYPE"
QBT_HOST="${QBT_HOST:-$(_arr_access_host "$LAN_IP")}" 
SONARR_PORT="$(_arr_get SONARR_PORT)"; [[ -n "$SONARR_PORT" ]] || SONARR_PORT=8989
RADARR_PORT="$(_arr_get RADARR_PORT)"; [[ -n "$RADARR_PORT" ]] || RADARR_PORT=7878
PROWLARR_PORT="$(_arr_get PROWLARR_PORT)"; [[ -n "$PROWLARR_PORT" ]] || PROWLARR_PORT=9696
BAZARR_PORT="$(_arr_get BAZARR_PORT)"; [[ -n "$BAZARR_PORT" ]] || BAZARR_PORT=6767
FLARESOLVERR_PORT="$(_arr_get FLARESOLVERR_PORT)"; [[ -n "$FLARESOLVERR_PORT" ]] || FLARESOLVERR_PORT=8191
SERVER_COUNTRIES="$(_arr_get SERVER_COUNTRIES)"
export SERVER_COUNTRIES
SERVER_CC_PRIORITY="$(_arr_get SERVER_CC_PRIORITY)"
if [[ -z "$SERVER_CC_PRIORITY" ]]; then
  SERVER_CC_PRIORITY="Australia,Singapore,Japan,Hong Kong,United States,United Kingdom,Netherlands,Germany,Switzerland,Spain,Romania,Luxembourg"
fi

# Known services in this project (compose names)
ARR_SERVICES=(gluetun qbittorrent sonarr radarr prowlarr bazarr flaresolverr)

# ----------------[ Project-level controls ]----------------
arr.up()       { _arr_dc up -d; }
arr.down()     { _arr_dc down; }
arr.restart()  { _arr_dc restart "$@"; }
arr.pull()     { _arr_dc pull "$@"; }
arr.ps()       { _arr_dc ps; }
  # shellcheck disable=SC2015
  arr.logs()     { local s="${1:-}"; shift || true; [[ -n "$s" ]] && _arr_dc logs -f --tail=200 "$s" "$@" || _arr_dc logs -f --tail=100; }
arr.tail()     { arr.logs "$@"; }
arr.stats()    { docker stats --no-stream "${ARR_SERVICES[@]}" 2>/dev/null || true; }
arr.shell()    { local s="${1:?service}"; docker exec -it "$s" /bin/bash 2>/dev/null || docker exec -it "$s" /bin/sh; }
arr.health()   { for s in "${ARR_SERVICES[@]}"; do printf "%-14s : %s\n" "$s" "$(docker inspect --format '{{.State.Health.Status}}' "$s" 2>/dev/null || echo n/a)"; done; }
arr.backup()   {
  local src="$ARR_DOCKER_DIR"
  local dst
  dst="$ARR_BACKUP_DIR/cli-$(_arr_now)"
  mkdir -p "$dst"
  for s in "${ARR_SERVICES[@]}"; do
    local dir="$src/$s" out="$dst/${s}-config.tgz"
    [[ -d "$dir" ]] && tar -C "$src" -czf "$out" "$s" && echo "saved -> $out"
  done
  echo "Backups in $dst"
}
arr.open()     {
  # Best-effort open in default browser (Linux desktop); otherwise just echo URLs
  local open_cmd
  if command -v xdg-open >/dev/null; then open_cmd="xdg-open"; else open_cmd=""; fi
  local host="$(_arr_access_host "$LAN_IP")"
  local qport="$QBT_HTTP_PORT_HOST"
    local urls=(
      "qBittorrent=$(_arr_url "$host" "$qport")"
      "Sonarr=$(_arr_url "$host" "$SONARR_PORT")"
      "Radarr=$(_arr_url "$host" "$RADARR_PORT")"
      "Prowlarr=$(_arr_url "$host" "$PROWLARR_PORT")"
      "Bazarr=$(_arr_url "$host" "$BAZARR_PORT")"
      "FlareSolverr=$(_arr_url "$host" "$FLARESOLVERR_PORT")"
    )
  for u in "${urls[@]}"; do
    local name="${u%%=*}" url="${u#*=}"
    echo "• $name -> $url"
      # shellcheck disable=SC2015
      [[ -n "$open_cmd" ]] && "$open_cmd" "$url" >/dev/null 2>&1 || true
  done
}

# ----------------[ Gluetun / ProtonVPN helpers ]----------------
# (This folds in the previous `pvpn` helper.)
pvpn() {
  local cmd="${1:-}"; shift || true
  local stack_dir="$ARR_STACK_DIR"; local env_file="$ARR_ENV_FILE"
  local creds_file="$PROTON_AUTH_FILE"
  _set(){
    local key="$1" v="$2"
    if [[ "$key" = "VPN_MODE" ]]; then
      key="VPN_TYPE"
    fi
    if [[ "$key" = "VPN_TYPE" ]]; then
      sed -i '/^VPN_MODE=/d' "$env_file" 2>/dev/null || true
    fi
    sed -i "/^${key}=/d" "$env_file" 2>/dev/null || true
    if [[ -n "$v" ]]; then
      echo "${key}=${v}" >>"$env_file"
    fi
    case "$key" in
      VPN_TYPE)
        VPN_TYPE="$v"
        VPN_MODE="$v"
        ;;
      GLUETUN_API_KEY)
        GLUETUN_API_KEY="$v"
        ;;
      GLUETUN_CONTROL_PORT)
        GLUETUN_CONTROL_PORT="$v"
        ;;
      QBT_HTTP_PORT_HOST)
        QBT_HTTP_PORT_HOST="$v"
        ;;
      QBT_USER)
        QBT_USER="$v"
        ;;
      QBT_PASS)
        QBT_PASS="$v"
        ;;
    esac
  }
  _restart(){ ( cd "$stack_dir" && docker compose --env-file "$env_file" restart gluetun ); }
  local auth="-u gluetun:${GLUETUN_API_KEY}"
  local ctl_host
  ctl_host="$(_arr_access_host "$GLUETUN_CONTROL_BIND_HOST")"

  case "$cmd" in
    c|connect)   ( cd "$stack_dir" && docker compose --env-file "$env_file" up -d gluetun qbittorrent );;
    r|reconnect) _restart;;
    mode)
      case "${1:-}" in
        openvpn|ovpn) _set VPN_TYPE openvpn; _restart;;
        wireguard|wg) _arr_warn "PF is less reliable on WG with Proton"; _set VPN_TYPE wireguard; _restart;;
        *) echo "Usage: pvpn mode [openvpn|wireguard]"; return 1;;
      esac;;
    creds)
      local user pass
      read -rp "Proton username (without +pmp): " user
      read -rsp "Password: " pass; echo
      sed -i '/^PROTON_USER=/d;/^PROTON_PASS=/d' "$creds_file" 2>/dev/null || true
      echo "PROTON_USER=${user}" >>"$creds_file"
      echo "PROTON_PASS=${pass}" >>"$creds_file"
      sed -i '/^OPENVPN_USER=/d;/^OPENVPN_PASSWORD=/d' "$env_file" 2>/dev/null || true
      echo "OPENVPN_USER=${user}+pmp" >>"$env_file"
      echo "OPENVPN_PASSWORD=${pass}" >>"$env_file"
      echo "Updated creds. Restarting gluetun…"
      _restart;;
    s|status)
      echo "-- Gluetun --"
      docker ps --filter name=gluetun --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' | tail -n +2
      echo "-- Public IP --";  curl -fsS "$auth" "http://${ctl_host}:${GLUETUN_CONTROL_PORT}/v1/publicip/ip" || echo N/A
      if [ "$VPN_TYPE" = "openvpn" ]; then
        echo "-- Forwarded port (OVPN) --"; curl -fsS "$auth" "http://${ctl_host}:${GLUETUN_CONTROL_PORT}/v1/openvpn/portforwarded" || echo N/A
      else
        echo "-- Forwarded port (WG) --";   curl -fsS "$auth" "http://${ctl_host}:${GLUETUN_CONTROL_PORT}/v1/wireguard/portforwarded" || echo N/A
      fi;;
    port)
      if [ "$VPN_TYPE" = "openvpn" ]; then
        curl -fsS "$auth" "http://${ctl_host}:${GLUETUN_CONTROL_PORT}/v1/openvpn/portforwarded"
      else
        curl -fsS "$auth" "http://${ctl_host}:${GLUETUN_CONTROL_PORT}/v1/wireguard/portforwarded"
      fi;;
    paths|path|where)
      echo "Proton auth: $creds_file"
      echo "WireGuard configs: $ARRCONF_DIR/wg*.conf"
      ;;
    *) cat <<USAGE
pvpn commands:
  connect|c        Start gluetun + qbittorrent
  reconnect|r      Restart gluetun
  mode <ovpn|wg>   Switch VPN mode (ovpn recommended for PF)
  creds            Update Proton username/password (adds +pmp)
  paths            Show expected credential locations
  status|s         Show container, public IP, forwarded port
  port             Print forwarded port only
USAGE
      ;;
  esac
}

glue.logs()   { arr.logs gluetun; }
glue.restart(){ docker restart gluetun; }
glue.ip()     { curl -fsS -u "gluetun:${GLUETUN_API_KEY}" "http://$(_arr_access_host "$LAN_IP"):${GLUETUN_CONTROL_PORT}/v1/publicip/ip"; echo; }
glue.pf()     { pvpn port; echo; }
glue.health() { docker inspect --format '{{.State.Health.Status}}' gluetun 2>/dev/null || echo n/a; }

arr_vpn_servers() {
  local host
  host="$(_arr_access_host "$LAN_IP")"
  curl -fsS -u "gluetun:${GLUETUN_API_KEY}" \
    "http://${host}:${GLUETUN_CONTROL_PORT}/v1/servers" |
    jq -r '.protonvpn[].country' | sort -u
}

_arr_vpn_switch() {
  local cc="$1"
  local host
  host="$(_arr_access_host "$LAN_IP")"
  if wget -qO- --method=PUT \
      --header="Content-Type: application/json" \
      --user="gluetun:${GLUETUN_API_KEY}" \
      "http://${host}:${GLUETUN_CONTROL_PORT}/v1/settings" \
      --post-data "{\"server_countries\":[\"${cc}\"]}" >/dev/null 2>&1; then
    echo "Requested Gluetun switch to: ${cc}"
    wget -qO- --method=PUT --user="gluetun:${GLUETUN_API_KEY}" \
      "http://${host}:${GLUETUN_CONTROL_PORT}/v1/openvpn/restart" >/dev/null 2>&1 || true
    return 0
  fi
  echo "Control API settings PUT not available; restarting with ${cc}…"
  SERVER_COUNTRIES="${cc}" _arr_dc up -d gluetun || return 1
  return 0
}

arr_vpn_country() {
  local cc="$*"
  if [ -z "$cc" ]; then
    echo "Usage: arr_vpn_country <Country Name>"; return 2
  fi
  local server_list
  server_list="$(arr_vpn_servers 2>/dev/null || true)"
  if [ -n "$server_list" ] && ! echo "$server_list" | grep -Fxq "$cc"; then
    _arr_warn "${cc} not in server list; using priority order"
    cc=""
  fi
  IFS=',' read -r -a cc_list <<< "${SERVER_CC_PRIORITY}"
  local candidates=()
  if [ -n "$cc" ]; then candidates+=("$cc"); fi
  for c in "${cc_list[@]}"; do
    [[ " ${candidates[*]} " == *" $c "* ]] || candidates+=("$c")
  done
  for cand in "${candidates[@]}"; do
    _arr_vpn_switch "$cand" && return 0
    _arr_warn "${cand} failed; trying next"
  done
  echo "All VPN country attempts failed"; return 1
}

arr_vpn_fastest() {
  local limit="${1:-6}"
  local tested=0 best_cc="" best_ms=""

  IFS=',' read -r -a cc_list <<< "${SERVER_CC_PRIORITY}"
  local server_list
  server_list="$(arr_vpn_servers 2>/dev/null || true)"
  for cc in "${cc_list[@]}"; do
    [ "$tested" -ge "$limit" ] && break
    if [ -n "$server_list" ] && ! echo "$server_list" | grep -Fxq "$cc"; then
      continue
    fi
    _arr_vpn_switch "$cc" >/dev/null 2>&1 || continue
    sleep 2
    local ms
    ms="$( (time -p nc -z -w 2 1.1.1.1 443) 2>&1 | awk '/real/{print $2*1000}' )" || ms="99999"
    echo "Probe ${cc}: ${ms} ms"
    if [ -z "$best_ms" ] || [ "${ms%.*}" -lt "${best_ms%.*}" ]; then
      best_ms="$ms"; best_cc="$cc"
    fi
    tested=$((tested+1))
  done

  if [ -n "$best_cc" ]; then
    echo "Fastest (heuristic): ${best_cc} (${best_ms} ms)"
    _arr_vpn_switch "$best_cc"
  else
    echo "No result; using priority order fallback: ${cc_list[0]}"
    _arr_vpn_switch "${cc_list[0]}"
  fi
}

# ----------------[ qBittorrent helpers ]----------------
_qbt_base()   { printf "http://%s:%s" "$QBT_HOST" "$QBT_HTTP_PORT_HOST"; }
_qbt_cookie() { printf "/tmp/qbt-%s.cookie" "$USER"; }

_qbt_login() {
  local u="$QBT_USER" p="$QBT_PASS"
  [[ -z "$u" || -z "$p" ]] && { _arr_warn "set QBT_USER/QBT_PASS in $ARR_ENV_FILE"; return 1; }
  curl -s -c "$(_qbt_cookie)" -X POST "$(_qbt_base)/api/v2/auth/login" \
       --data-urlencode "username=$u" --data-urlencode "password=$p" >/dev/null
}
_qbt_get()    { _qbt_login >/dev/null 2>&1; curl -s -b "$(_qbt_cookie)" "$(_qbt_base)$1"; }
_qbt_post()   { _qbt_login >/dev/null 2>&1; curl -s -b "$(_qbt_cookie)" -X POST "$(_qbt_base)$1" "${@:2}"; }

  # shellcheck disable=SC2005
  qbt.url()     { echo "$(_qbt_base)"; }
qbt.logs()    { arr.logs qbittorrent; }
qbt.restart() { docker restart qbittorrent; }
qbt.port.get(){ _qbt_get "/api/v2/app/preferences" | jq -r '.listen_port // empty'; }
qbt.port.set(){ local p="${1:?port}"; _qbt_post "/api/v2/app/setPreferences" --data-urlencode "json={\"listen_port\":${p}}"; echo "listen_port -> $p"; }
qbt.port.sync(){  # sync qB to Gluetun forwarded port (using Gluetun API)
  local pf; pf="$(pvpn port 2>/dev/null | jq -r '.port // empty' 2>/dev/null || true)"
  [[ -z "$pf" ]] && pf="$(pvpn port 2>/dev/null | tr -dc '0-9')"  # fallback parse
  [[ -z "$pf" ]] && { _arr_warn "no forwarded port yet"; return 1; }
  qbt.port.set "$pf"
}
qbt.list()    { _qbt_get "/api/v2/torrents/info?filter=all" | jq -r '.[].name'; }
qbt.pause.all(){ _qbt_post "/api/v2/torrents/pause?hashes=all"; echo "paused all"; }
qbt.resume.all(){ _qbt_post "/api/v2/torrents/resume?hashes=all"; echo "resumed all"; }
qbt.reannounce(){ _qbt_post "/api/v2/torrents/reannounce?hashes=${1:-all}"; echo "reannounce ${1:-all}"; }
qbt.add.url(){ local u="${1:?torrent/magnet URL}"; _qbt_post "/api/v2/torrents/add" --data-urlencode "urls=$u"; echo "added: $u"; }
qbt.limit()   { local down="${1:-0}" up="${2:-0}"; _qbt_post "/api/v2/transfer/setDownloadLimit?limit=$down"; _qbt_post "/api/v2/transfer/setUploadLimit?limit=$up"; echo "limits -> down:$down up:$up (0=unlimited)"; }

# ----------------[ Sonarr / Radarr / Prowlarr / Bazarr ]----------------
# Optional: set API keys to enable API tasks (found in each app’s UI)
#   export SONARR_API_KEY=xxxxx
#   export RADARR_API_KEY=xxxxx
#   export PROWLARR_API_KEY=xxxxx
#   export BAZARR_API_KEY=xxxxx

# ---- Common UI helpers
  # shellcheck disable=SC2005
  sonarr.url()    { echo "$(_arr_url "$LAN_IP" "$SONARR_PORT")"; }
  # shellcheck disable=SC2005
  radarr.url()    { echo "$(_arr_url "$LAN_IP" "$RADARR_PORT")"; }
  # shellcheck disable=SC2005
  prowlarr.url()  { echo "$(_arr_url "$LAN_IP" "$PROWLARR_PORT")"; }
  # shellcheck disable=SC2005
  bazarr.url()    { echo "$(_arr_url "$LAN_IP" "$BAZARR_PORT")"; }

# ---- Logs / restart
sonarr.logs()   { arr.logs sonarr; }   ; sonarr.restart()   { docker restart sonarr; }
radarr.logs()   { arr.logs radarr; }   ; radarr.restart()   { docker restart radarr; }
prowlarr.logs() { arr.logs prowlarr; } ; prowlarr.restart() { docker restart prowlarr; }
bazarr.logs()   { arr.logs bazarr; }   ; bazarr.restart()   { docker restart bazarr; }

# ---- API helpers (if API keys are set)
  sonarr.api()    { curl -s -H "X-Api-Key: ${SONARR_API_KEY:?set SONARR_API_KEY}" "$(_arr_url "$LAN_IP" "$SONARR_PORT")$1" "${@:2}"; }
  radarr.api()    { curl -s -H "X-Api-Key: ${RADARR_API_KEY:?set RADARR_API_KEY}" "$(_arr_url "$LAN_IP" "$RADARR_PORT")$1" "${@:2}"; }
  prowlarr.api()  { curl -s -H "X-Api-Key: ${PROWLARR_API_KEY:?set PROWLARR_API_KEY}" "$(_arr_url "$LAN_IP" "$PROWLARR_PORT")$1" "${@:2}"; }
  bazarr.api()    { curl -s -H "X-Api-Key: ${BAZARR_API_KEY:?set BAZARR_API_KEY}" "$(_arr_url "$LAN_IP" "$BAZARR_PORT")$1" "${@:2}"; }

# ---- Common tasks (Sonarr/Radarr)
sonarr.refresh() { sonarr.api "/api/v3/command" -H 'Content-Type: application/json' -d '{"name":"RefreshSeries"}'; echo "Sonarr: refresh series"; }
sonarr.rss()     { sonarr.api "/api/v3/command" -H 'Content-Type: application/json' -d '{"name":"RssSync"}'; echo "Sonarr: RSS sync"; }
radarr.refresh() { radarr.api "/api/v3/command" -H 'Content-Type: application/json' -d '{"name":"RefreshMovie"}'; echo "Radarr: refresh movies"; }
radarr.rss()     { radarr.api "/api/v3/command" -H 'Content-Type: application/json' -d '{"name":"RssSync"}'; echo "Radarr: RSS sync"; }

# ---- Prowlarr: (simple checks; full indexer mgmt available via UI)
prowlarr.status(){ prowlarr.api "/api/v1/system/status" | jq; }

# ---- Bazarr health
  bazarr.health()  { curl -fsS "$(_arr_url "$LAN_IP" "$BAZARR_PORT")/api/system/status?apikey=${BAZARR_API_KEY:-}" || echo "Bazarr status requires API key"; echo; }

# ----------------[ FlareSolverr ]----------------
  # shellcheck disable=SC2005
  flare.url()     { echo "$(_arr_url "$LAN_IP" "$FLARESOLVERR_PORT")"; }
  flare.health()  { curl -fsS "$(_arr_url "$LAN_IP" "$FLARESOLVERR_PORT")/health" || echo "not responding"; echo; }
flare.logs()    { arr.logs flaresolverr; }
flare.restart() { docker restart flaresolverr; }

# ----------------[ Convenience aliases ]----------------
alias arrup='arr.up'
alias arrdown='arr.down'
alias arrps='arr.ps'
alias arrlogs='arr.logs'
alias arrtail='arr.tail'
alias arrstats='arr.stats'
alias arrhealth='arr.health'
alias arrbackup='arr.backup'
alias arropen='arr.open'
alias arrsh='arr.shell'

alias qbturl='qbt.url'
alias qbtlogs='qbt.logs'
alias qbtport='qbt.port.get'
alias qbtportsync='qbt.port.sync'
alias qbtpause='qbt.pause.all'
alias qbtresume='qbt.resume.all'
alias qbtreannounce='qbt.reannounce'
alias qbtadd='qbt.add.url'

alias pvpnstatus='pvpn status'
alias pvpnconnect='pvpn connect'
alias pvpnreconnect='pvpn reconnect'
alias pvpnmode='pvpn mode'
alias arrvpncountry='arr_vpn_country'
alias arrvpnfastest='arr_vpn_fastest'
alias arrvpnservers='arr_vpn_servers'

# End of arr-stack/.aliasarr
